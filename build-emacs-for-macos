#!/usr/bin/env ruby
# frozen_string_literal: true

require 'English'
require 'date'
require 'erb'
require 'etc'
require 'fileutils'
require 'json'
require 'logger'
require 'net/http'
require 'optparse'
require 'pathname'
require 'time'
require 'tmpdir'
require 'uri'
require 'yaml'

require 'macho'

class Error < StandardError
end

module Output
  class << self
    LEVELS = {
      debug: Logger::DEBUG,
      error: Logger::ERROR,
      fatal: Logger::FATAL,
      info: Logger::INFO,
      unknown: Logger::UNKNOWN,
      warn: Logger::WARN
    }.freeze

    def log_level
      LEVELS.key(logger.level)
    end

    def log_level=(level)
      logger.level = LEVELS.fetch(level&.to_sym)
    end

    def logger
      @logger ||=
        Logger
        .new($stderr)
        .tap do |logger|
          logger.level = Logger::INFO
          logger.formatter =
            proc do |severity, _datetime, _progname, msg|
              "==> #{severity.upcase}: #{msg}"
            end
        end
    end
  end

  %i[debug info warn error].each do |severity|
    define_method(severity) do |msg, newline: true|
      logger.send(severity, format_msg(msg, newline: newline))
    end
  end

  def fatal(msg = nil)
    raise Error, msg
  end

  private

  def logger
    Output.logger
  end

  def format_msg(msg, newline: true)
    msg = msg.join("\n") if msg.is_a?(Array)
    msg = msg.strip
    msg = "#{msg}\n" if newline
    msg
  end
end

module System
  include Output

  def run_cmd(*args)
    debug "executing: #{args.join(' ')}"
    cmd(*args)
  end

  def cmd(*args)
    system(*args) || fatal("Exit code: #{$CHILD_STATUS.exitstatus}")
  end
end

class OS
  def self.version
    @version ||= OSVersion.new
  end

  def self.arch
    @arch ||= `uname -m`.strip
  end
end

class OSVersion
  def initialize
    @version =
      `sw_vers -productVersion`.match(
        /(?<major>\d+)(?:\.(?<minor>\d+)(?:\.(?<patch>\d+))?)?/
      )
  end

  def to_s
    @to_s ||= major >= 11 ? major.to_s : "#{major}.#{minor}"
  end

  def major
    @major ||= @version[:major]&.to_i
  end

  def minor
    @minor ||= @version[:minor]&.to_i
  end

  def patch
    @patch ||= @version[:patch]&.to_i
  end
end

class Build
  include Output
  include System

  DEFAULT_GITHUB_REPO = 'emacs-mirror/emacs'

  attr_reader :root_dir
  attr_reader :source_dir
  attr_reader :ref
  attr_reader :options
  attr_reader :gcc_info

  def initialize(root_dir, ref = nil, options = {})
    @root_dir = root_dir
    @ref = ref || 'master'
    @options = options
    @gcc_info = GccInfo.new
  end

  def build
    load_plan(options[:plan]) if options[:plan]

    unless meta[:sha] && meta[:date]
      fatal 'Failed to get commit info from GitHub.'
    end

    tarball = download_tarball(meta[:sha])
    @source_dir = extract_tarball(tarball, patches(options))

    autogen
    detect_native_comp if options[:native_comp].nil?

    app = compile_source(@source_dir)
    build_dir, app = create_build_dir(app)

    handle_native_lisp(app)

    CLIHelperEmbedder.new(app).embed
    CSourcesEmbedder.new(app, @source_dir).embed
    LibEmbedder.new(
      app,
      brew_dir,
      extra_libs,
      relink_eln_files: options[:relink_eln]
    ).embed
    GccLibEmbedder.new(app, gcc_info).embed if options[:native_comp]
    self_sign_app(app) if options[:self_sign]

    archive_build(build_dir) if options[:archive]
  end

  private

  def load_plan(filename)
    debug "Loading plan from: #{filename}"
    plan = YAML.safe_load(File.read(filename), permitted_classes: [:Time])

    @ref = plan.dig('source', 'ref')
    @meta = {
      sha: plan.dig('source', 'commit', 'sha'),
      ref: @ref,
      date: plan.dig('source', 'commit', 'date')
    }

    if plan.dig('output', 'directory')
      @output_dir = plan.dig('output', 'directory')
    end

    if plan.dig('output', 'archive')
      @archive_filename = plan.dig('output', 'archive')
    end

    @build_name = plan.dig('build', 'name') if plan.dig('build', 'name')
  end

  def tarballs_dir
    @tarballs_dir ||= File.join(root_dir, 'tarballs')
  end

  def sources_dir
    @sources_dir ||= File.join(root_dir, 'sources')
  end

  def output_dir
    @output_dir ||= options[:output] || File.join(root_dir, 'builds')
  end

  def github_src_repo
    @github_src_repo ||= options[:github_src_repo] || DEFAULT_GITHUB_REPO
  end

  def brew_dir
    @brew_dir ||= `brew --prefix`.chomp
  end

  def extra_libs
    return @extra_libs if @extra_libs

    libs = [
      File.join(brew_dir, 'opt/expat/lib/libexpat.1.dylib'),
      File.join(brew_dir, 'opt/libiconv/lib/libiconv.2.dylib'),
      File.join(brew_dir, 'opt/zlib/lib/libz.1.dylib')
    ]

    if options[:native_comp]
      libgcc_s =
        File.join(
          brew_dir,
          'lib',
          'gcc',
          gcc_info.major_version,
          'libgcc_s.1.dylib'
        )
      libs << libgcc_s if File.exist?(libgcc_s)
    end

    @extra_libs = libs
  end

  def download_tarball(sha)
    FileUtils.mkdir_p(tarballs_dir)

    url = "https://github.com/#{github_src_repo}/tarball/#{sha}"
    filename = "#{github_src_repo.gsub(/[^a-zA-Z0-9-]+/, '-')}-#{sha[0..6]}.tgz"
    target = File.join(tarballs_dir, filename)

    if File.exist?(target)
      info "#{filename} already exists locally, attempting to use."
      return target
    end

    info 'Downloading tarball from GitHub. This could take a while, ' \
         'please be patient.'

    args = ['curl', '-L', url, '-o', target]
    log_args = args.clone

    if options[:github_auth] && ENV['GITHUB_TOKEN']
      args =
        [args[0]] + ['-H', "Authorization: Token #{ENV['GITHUB_TOKEN']}"] +
        args[1..-1]
      log_args =
        [log_args[0]] + ['-H', '"Authorization: Token $GITHUB_TOKEN"'] +
        log_args[1..-1]
    end

    debug "executing: #{log_args.join(' ')}"
    cmd(*args)

    target
  end

  def extract_tarball(filename, patches = [])
    FileUtils.mkdir_p(sources_dir)

    dirname = File.basename(filename).gsub(/\.\w+$/, '')
    target = File.join(sources_dir, dirname)

    if File.exist?(target)
      info "#{dirname} source tree exists, attempting to use."
      return target
    end

    info 'Extracting tarball...'
    result = run_cmd('tar', '-xzf', filename, '-C', sources_dir)
    fatal 'Tarball extraction failed.' unless result

    patches.each { |patch| apply_patch(patch, target) }

    target
  end

  def configure_help
    return @configure_help if @configure_help

    FileUtils.cd(source_dir) { @configure_help = `./configure --help` }

    @configure_help
  end

  def supports_xwidgets?
    @supports_xwidgets ||= !!configure_help.match(/\s+--with-xwidgets\s+/)
  end

  def supports_tree_sitter?
    @supports_tree_sitter ||=
      !!configure_help.match(/\s+--with-tree-sitter(\s|=).+/)
  end

  def supports_native_comp?
    @supports_native_comp ||= !native_comp_configure_flag.nil?
  end

  def native_comp_configure_match
    @native_comp_configure_match ||=
      configure_help.match(/\s+?(--with-native(?:comp|-compilation))(.+)?\s+?/)
  end

  def native_comp_configure_flag
    return @native_comp_configure_flag if @native_comp_configure_flag

    return unless native_comp_configure_match&.[](1)

    @native_comp_configure_flag = [
      native_comp_configure_match[1],
      native_comp_configure_flag_arg
    ].compact.join('=')
  end

  def native_comp_configure_flag_arg
    return @native_comp_configure_flag_arg if @native_comp_configure_flag_arg

    return if native_comp_configure_match&.[](2) != '[=TYPE]'

    @native_comp_configure_flag_arg =
      (options[:native_full_aot] ? 'aot' : 'yes')
  end

  def detect_native_comp
    info 'Detecting native-comp support...'
    options[:native_comp] = supports_native_comp?
    info 'Native-comp is: ' \
         "#{options[:native_comp] ? 'Supported' : 'Not supported'}"
  end

  def verify_native_comp
    return if supports_native_comp?

    fatal 'This emacs source tree does not support native-comp'
  end

  def autogen
    FileUtils.cd(source_dir) do
      if File.exist?('autogen/copy_autogen')
        run_cmd 'autogen/copy_autogen'
      elsif File.exist?('autogen.sh')
        run_cmd './autogen.sh'
      end
    end
  end

  def compile_source(source)
    target = File.join(source, 'nextstep')
    emacs_app = File.join(target, 'Emacs.app')

    if File.exist?(emacs_app)
      info 'Emacs.app already exists in ' \
           "\"#{target.gsub("#{root_dir}/", '')}\", attempting to use."
      return emacs_app
    end

    info 'Compiling from source. This will take a while...'

    FileUtils.cd(source) do
      if options[:native_comp]
        info 'Compiling with native-comp enabled'
        verify_native_comp
        gcc_info.verify_libgccjit

        ENV['CFLAGS'] = [
          "-I#{File.join(gcc_info.root_dir, 'include')}",
          "-I#{File.join(gcc_info.libgccjit_root_dir, 'include')}",
          '-O2',
          (options[:native_march] ? '-march=native' : nil),
          ENV.fetch('CFLAGS', nil)
        ].compact.join(' ')

        ENV['LDFLAGS'] = [
          "-L#{gcc_info.lib_dir}",
          "-L#{gcc_info.darwin_lib_dir}",
          "-L#{gcc_info.libgccjit_lib_dir}",
          "-I#{File.join(gcc_info.root_dir, 'include')}",
          "-I#{File.join(gcc_info.libgccjit_root_dir, 'include')}",
          # Ensure library re-linking and code signing will work after building.
          '-Wl,-headerpad_max_install_names',
          ENV.fetch('LDFLAGS', nil)
        ].compact.join(' ')

        ENV['LIBRARY_PATH'] = [
          gcc_info.lib_dir,
          gcc_info.darwin_lib_dir,
          gcc_info.libgccjit_lib_dir,
          ENV.fetch('LIBRARY_PATH', nil)
        ].compact.join(':')
      end

      if options[:fd_setsize].respond_to?(:>=) && options[:fd_setsize] >= 1024
        ENV['CFLAGS'] = [
          "-DFD_SETSIZE=#{options[:fd_setsize]}",
          '-DDARWIN_UNLIMITED_SELECT',
          ENV.fetch('CFLAGS', nil)
        ].compact.join(' ')
      end

      ENV['CC'] = 'clang'
      ENV['PKG_CONFIG_PATH'] = [
        File.join(brew_dir, 'lib/pkgconfig'),
        File.join(brew_dir, 'share/pkgconfig'),
        File.join(brew_dir, 'opt/expat/lib/pkgconfig'),
        File.join(brew_dir, 'opt/libxml2/lib/pkgconfig'),
        File.join(brew_dir, 'opt/ncurses/lib/pkgconfig'),
        File.join(brew_dir, 'opt/zlib/lib/pkgconfig'),
        File.join(
          brew_dir,
          'Homebrew/Library/Homebrew/os/mac/pkgconfig',
          OS.version.to_s
        ),
        ENV.fetch('PKG_CONFIG_PATH', nil)
      ].compact.join(':')

      ENV['PATH'] = [
        File.join(brew_dir, 'opt/make/libexec/gnubin'),
        File.join(brew_dir, 'opt/coreutils/libexec/gnubin'),
        File.join(brew_dir, 'opt/gnu-sed/libexec/gnubin'),
        File.join(brew_dir, 'bin'),
        File.join(brew_dir, 'opt/texinfo/bin'),
        ENV.fetch('PATH', nil)
      ].compact.join(':')

      ENV['LIBRARY_PATH'] = [
        ENV.fetch('LIBRARY_PATH', nil),
        '/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/lib'
      ].compact.join(':')

      local_lisp_path = [
        ENV.fetch('EMACS_LOCAL_LISP_PATH', '').split(':'),
        '/Library/Application Support/Emacs/${version}/site-lisp',
        '/Library/Application Support/Emacs/site-lisp',
        '/usr/local/share/emacs/site-lisp',
        '/opt/homebrew/share/emacs/site-lisp'
      ].flatten.join(':')

      configure_flags = [
        '--with-ns',
        '--with-modules',
        "--enable-locallisppath=#{local_lisp_path}"
      ]
      if options[:xwidgets] && supports_xwidgets?
        configure_flags << '--with-xwidgets'
      end
      if options[:tree_sitter] && supports_tree_sitter?
        configure_flags << '--with-tree-sitter'
      end
      configure_flags << native_comp_configure_flag if options[:native_comp]
      configure_flags << '--without-rsvg' if options[:rsvg] == false
      configure_flags << '--without-dbus' if options[:dbus] == false

      run_cmd './configure', *configure_flags.compact

      # Disable aligned_alloc on Mojave and below. See issue:
      # https://github.com/daviderestivo/homebrew-emacs-head/issues/15
      if OS.version.major <= 10 && OS.version.minor <= 14
        info 'Force disabling of aligned_alloc on macOS Mojave (10.14.x) ' \
             'and earlier'
        disable_alligned_alloc
      end

      make_flags = []
      make_flags += ['-j', options[:parallel].to_s] if options[:parallel]

      if options[:native_comp]
        make_flags << "BYTE_COMPILE_EXTRA_FLAGS=--eval '(setq comp-speed 2)'"

        if options[:native_full_aot]
          info 'Using native compile full AOT'
          # We do not need to supply the full AOT make arg if
          # --with-native-compilation=aot configure flag is supported.
          unless native_comp_configure_flag_arg
            make_flags << 'NATIVE_FULL_AOT=1'
          end
          ENV.delete('NATIVE_FAST_BOOT')
        else
          ENV.delete('NATIVE_FULL_AOT')
          ENV['NATIVE_FAST_BOOT'] = '1'
        end
      end

      run_cmd 'make', *make_flags.compact
      run_cmd 'make', 'install'
    end

    fatal 'Build failed.' unless File.exist?(emacs_app)

    emacs_app
  end

  def create_build_dir(app)
    app_name = File.basename(app)
    target_dir = File.join(output_dir, build_name)

    if File.exist?(target_dir)
      fatal "Output directory #{target_dir} already exists, " \
            'please delete it and try again'
    end

    info "Copying \"#{app_name}\" to: #{target_dir}"

    FileUtils.mkdir_p(target_dir)
    cmd('cp', '-a', app, target_dir)

    options[:dist_include]&.each do |filename|
      src = File.join(source_dir, filename)
      if File.exist?(src)
        info "Copying \"#{filename}\" to: #{target_dir}"
        cmd('cp', '-pRL', src, target_dir)
      else
        info "Warning: #{filename} does not exist in #{source_dir}"
      end
    end

    [target_dir, File.join(target_dir, File.basename(app))]
  end

  def handle_native_lisp(app)
    return unless options[:native_comp]

    contents_dir = File.join(app, 'Contents')

    FileUtils.cd(contents_dir) do
      source =
        Dir[
          'MacOS/libexec/emacs/**/eln-cache',
          'MacOS/lib/emacs/**/native-lisp'
        ].first

      # Skip creation of symlinks if *.eln files are not located in a location
      # known to be used by builds which need symlinks and other tweaks.
      return if source.nil?

      info 'Creating symlinks within Emacs.app needed for native-comp'

      if !File.exist?('lisp') && File.exist?('Resources/lisp')
        run_cmd('ln', '-s', 'Resources/lisp', 'lisp')
      end

      # Check for folder name containing two dots (.), as this causes Apple's
      # codesign CLI tool to fail signing the Emacs.app bundle, complaining with
      # q "bundle format unrecognized" error.
      #
      # The workaround for now is to rename the folder replacing the dots with
      # hyphens (-), and create the native-lisp symlink pointing to the new
      # location.
      eln_dir = File.dirname(Dir[File.join(source, '**', '*.eln')].first)

      if eln_dir.match(%r{/.+\..+\..+/})
        base = File.basename(eln_dir)
        parent = File.dirname(eln_dir)

        until ['.', '/', contents_dir].include?(parent)
          if base.match(/\..+\./)
            old_name = File.join(parent, base)
            new_name = File.join(parent, base.gsub(/\.(.+)\./, '-\\1-'))

            info "Renaming: #{old_name} --> #{new_name}"
            cmd('mv', old_name, new_name)
          end

          base = File.basename(parent)
          parent = File.dirname(parent)
        end

        eln_parts =
          eln_dir.match(
            %r{/(\d+\.\d+\.\d+)/native-lisp/(\d+\.\d+\.\d+-\w+)(?:/.+)?$}i
          )
        if eln_parts
          patch_dump_native_lisp_paths(app, eln_parts[1], eln_parts[2])
        end

        # Find native-lisp directory again after it has been renamed.
        source =
          Dir[
            'MacOS/libexec/emacs/**/eln-cache',
            'MacOS/lib/emacs/**/native-lisp'
          ].first

        if source.nil?
          fatal 'Failed to find native-lisp cache directory for ' \
                'symlink creation.'
        end
      end

      target = File.basename(source)
      run_cmd('ln', '-s', source, target) unless File.exist?(target)
    end
  end

  def patch_dump_native_lisp_paths(app, emacs_version, eln_version)
    sanitized_emacs_version = emacs_version.gsub('.', '-')
    sanitized_eln_version = eln_version.gsub('.', '-')

    contents_dir = File.join(app, 'Contents')
    FileUtils.cd(contents_dir) do
      filename = Dir['MacOS/Emacs.pdmp', 'MacOS/libexec/Emacs.pdmp'].first
      fatal "no Emacs.pdmp file found in #{app}" unless filename
      info 'patching Emacs.pdmp to point at new native-lisp paths'

      content =
        File
        .read(filename, mode: 'rb')
        .gsub(
          "lib/emacs/#{emacs_version}/native-lisp/#{eln_version}/",
          "lib/emacs/#{sanitized_emacs_version}/" \
          "native-lisp/#{sanitized_eln_version}/"
        )
        .gsub(
          "../native-lisp/#{eln_version}/",
          "../native-lisp/#{sanitized_eln_version}/"
        )

      File.write(filename, content)
    end
  end

  def build_name
    return @build_name if @build_name
    return @build_name = options[:build_name] if options[:build_name]

    metadata =
      [
        meta[:date]&.strftime('%Y-%m-%d'),
        meta[:sha][0..6],
        meta[:ref],
        "macOS-#{OS.version}",
        OS.arch
      ].compact.map { |v| v.gsub(/[^\w_-]+/, '-') }

    @build_name = "Emacs.#{metadata.join('.')}"
  end

  def archive_filename
    @archive_filename ||= File.join(output_dir, "#{build_name}.tbz")
  end

  def self_sign_app(app)
    cmd('codesign', '--force', '--deep', '-s', '-', app)
  end

  def archive_build(build_dir)
    filename = File.basename(archive_filename)
    target_dir = File.dirname(archive_filename)

    FileUtils.mkdir_p(target_dir)

    build = File.basename(build_dir)
    parent_dir = File.dirname(build_dir)

    if File.exist?(archive_filename)
      info "#{filename} archive exists in " \
           "#{target_dir}, skipping archving."
    else
      info "Creating #{filename} archive in \"#{target_dir}\"..."
      FileUtils.cd(parent_dir) do
        cmd('tar', '-cjf', archive_filename, build)

        if options[:archive_keep] == false
          info "Removing \"#{build}\" directory from #{parent_dir}"
          FileUtils.rm_rf(build_dir)
        end
      end
    end
  end

  def disable_alligned_alloc
    filename = 'src/config.h'
    content =
      File
      .read(filename)
      .gsub('#define HAVE_ALIGNED_ALLOC 1', '#undef HAVE_ALIGNED_ALLOC')
      .gsub(
        '#define HAVE_DECL_ALIGNED_ALLOC 1',
        '#undef HAVE_DECL_ALIGNED_ALLOC'
      )
      .gsub('#define HAVE_ALLOCA 1', '#undef HAVE_ALLOCA')
      .gsub('#define HAVE_ALLOCA_H 1', '#undef HAVE_ALLOCA_H')

    File.write(filename, content)
  end

  def meta
    return @meta if @meta

    ref_sha = options[:git_sha] || ref
    info "Fetching info for git ref: #{ref_sha}"
    commit_json = github_api_get("/repos/#{github_src_repo}/commits/#{ref_sha}")
    fatal "Failed to get commit info about: #{ref_sha}" if commit_json.nil?

    commit = JSON.parse(commit_json)
    meta = {
      sha: commit['sha'],
      date: Time.parse(commit['commit']['committer']['date'])
    }
    meta[:ref] = ref if ref && ref[0..6] != meta[:sha][0..6]

    @meta = meta
  end

  def github_api_get(uri)
    uri = URI.join('https://api.github.com/', uri)

    http = Net::HTTP.new(uri.hostname, uri.port)
    http.use_ssl = true if uri.scheme == 'https'

    request = Net::HTTP::Get.new(uri)
    if options[:github_auth] && ENV['GITHUB_TOKEN']
      request['Authorization'] = "Token #{ENV['GITHUB_TOKEN']}"
    end

    response = http.request(request)
    return unless response.code == '200'

    response.body
  end

  def effective_version
    @effective_version ||=
      case ref
      when /^emacs-26.*/
        26
      when /^emacs-27.*/
        27
      when /^emacs-28.*/
        28
      when /^emacs-29.*/
        29
      when /^emacs-30.*/
        30
      else
        31
      end
  end

  def patches(opts = {})
    p = []

    # Enabled by default patches.

    if (26..31).include?(effective_version)
      p << {
        url:
          'https://github.com/d12frosted/homebrew-emacs-plus/raw/master/' \
          "patches/emacs-#{effective_version}/fix-window-role.patch"
      }
    end

    if (27..31).include?(effective_version)
      p << {
        url:
        'https://github.com/d12frosted/homebrew-emacs-plus/raw/master/' \
        "patches/emacs-#{effective_version}/system-appearance.patch"
      }
    end

    if (29..31).include?(effective_version)
      p << {
        url:
        'https://github.com/d12frosted/homebrew-emacs-plus/raw/master/' \
        "patches/emacs-#{effective_version}/round-undecorated-frame.patch"
      }
    end

    if effective_version == 27
      p << {
        url:
        'https://github.com/d12frosted/homebrew-emacs-plus/raw/master/' \
        "patches/emacs-#{effective_version}/ligatures-freeze-fix.patch"
      }
    end

    if effective_version == 28
      p << {
        replace: [
          'configure.ac',
          'grep libgccjit.so\$',
          'grep -E \'libgccjit\.(so|dylib)$\''
        ],
        allow_failure: true
      }
    end

    if (28..29).include?(effective_version)
      p << {
        replace: [
          'configure.ac',
          'grep -E \'libgccjit\.(so|dylib)$\'',
          'grep -E \'libgccjit\.(so|dylib)$\' | tail -1'
        ],
        allow_failure: true
      }
    end

    # Optional patches.

    if options[:no_frame_refocus] && (27..31).include?(effective_version)
      p << {
        url:
          'https://github.com/d12frosted/homebrew-emacs-plus/raw/master/' \
          "patches/emacs-#{effective_version}/no-frame-refocus-cocoa.patch"
      }
    end

    if options[:no_titlebar] && (27..28).include?(effective_version)
      p << {
        url:
        'https://github.com/d12frosted/homebrew-emacs-plus/raw/master/' \
        "patches/emacs-#{effective_version}/no-titlebar.patch"
      }
    end

    if opts[:xwidgets] && effective_version == 27
      p << {
        url:
          'https://github.com/d12frosted/homebrew-emacs-plus/raw/master/' \
          "patches/emacs-#{effective_version}/xwidgets_webkit_in_cocoa.patch"
      }
    end

    p.uniq
  end

  def apply_patch(patch, target)
    fatal "\"#{target}\" does not exist." unless File.exist?(target)

    if patch[:file]
      info 'Applying patch...'
      FileUtils.cd(target) { run_cmd('patch', '-f', '-p1', '-i', patch[:file]) }
    elsif patch[:url]
      patch_dir = "#{target}/macos_patches"
      run_cmd('mkdir', '-p', patch_dir)

      patch_file = File.join(patch_dir, 'patch-{num}.diff')
      num = 1
      while File.exist?(patch_file.gsub('{num}', num.to_s.rjust(3, '0')))
        num += 1
      end
      patch_file = patch_file.gsub('{num}', num.to_s.rjust(3, '0'))

      info "Downloading patch: #{patch[:url]}"
      run_cmd('curl', '-L#', patch[:url], '-o', patch_file)

      real_patch_url = detect_github_symlink_patch(patch[:url], patch_file)
      if real_patch_url
        FileUtils.rm(patch_file)
        apply_patch({ url: real_patch_url }, target)
      else
        apply_patch({ file: patch_file }, target)
      end
    elsif patch[:replace]
      fatal 'Patch replace input error' unless patch[:replace].size == 3

      file, before, after = patch[:replace]
      info "Applying patch to #{file}..."
      filepath = File.join(target, file)

      unless File.exist?(filepath)
        if patch[:allow_failure]
          info "File #{filepath} does not exist, skipping patch."
          return
        end

        fatal "\"#{file}\" does not exist in #{target}"
      end

      f = File.open(filepath, 'rb')
      s = f.read
      sub = s.gsub!(before, after)

      if sub.nil?
        if patch[:allow_failure]
          info 'Patch did not apply, skipping.'
          return
        end

        fatal "Replacement failed in #{file}"
      end

      f.reopen(filepath, 'wb').write(s)
      f.close
      info "#{file} patched."
    end
  end

  # When downloading raw files from GitHub, if the target file is a symlink, it
  # will return the actual target path of the symlink instead of the content of
  # the target file. Hence we have to check if the patch file we have downloaded
  # contains one and only one line, and if so, assume it's a symlink.
  def detect_github_symlink_patch(original_url, patch_file)
    lines = []

    # read first two lines
    File.open(patch_file) do |f|
      lines << f.gets
      lines << f.gets
    end

    # if the file contains more than one line of text, it's not a symlink.
    return unless lines[1].nil?

    symlink_target = lines[0].strip
    # Assume patch file content is something along the lines of
    # "../emacs-28/fix-window-role.patch", hence we resolve it relative to the
    # original url.
    info "patch is symlink to #{symlink_target}"
    URI.join(original_url, symlink_target).to_s
  end
end

class AbstractEmbedder
  include Output
  include System

  attr_reader :app

  def initialize(app)
    fatal "#{app} does not exist" unless File.exist?(app)

    @app = app
  end

  def relative_path(path)
    Pathname.new(path).relative_path_from(Pathname.new(app)).to_s
  end

  def invocation_dir
    @invocation_dir ||= File.join(app, 'Contents', 'MacOS')
  end

  def bin
    @bin ||= File.join(invocation_dir, 'Emacs')
  end

  def bin_dir
    @bin_dir ||= File.join(invocation_dir, 'bin')
  end

  def lib_dir
    @lib_dir ||= frameworks_dir
  end

  def frameworks_dir
    @frameworks_dir ||= File.join(app, 'Contents', 'Frameworks')
  end

  def resources_dir
    @resources_dir ||= File.join(app, 'Contents', 'Resources')
  end
end

class CLIHelperEmbedder < AbstractEmbedder
  def embed
    source = File.join(__dir__, 'helper', 'emacs-cli.bash')
    target = File.join(bin_dir, 'emacs')
    dir = File.dirname(target)

    info 'Adding "emacs" CLI helper to Emacs.app'

    FileUtils.mkdir_p(dir)
    run_cmd('cp', '-pRL', source, target)
    run_cmd('chmod', '+w', target)
  end
end

class CSourcesEmbedder < AbstractEmbedder
  PATH_PATCH = <<~ELISP
    ;; Allow Emacs to find bundled C sources.
    (setq source-directory
      (expand-file-name ".." (file-name-directory load-file-name)))
  ELISP

  attr_reader :source_dir

  def initialize(app, source_dir)
    super(app)

    @source_dir = source_dir
  end

  def embed
    info 'Bundling C source files into Emacs.app for documentation purposes...'

    src_dir = File.join(source_dir, 'src')
    target_dir = File.join(resources_dir, 'src')
    debug "Copying *.c and *.h files from '#{src_dir}' " \
          "to: #{relative_path(target_dir)}"

    Dir[File.join(src_dir, '**', '*.{c,h}')].each do |f|
      rel = f[src_dir.size + 1..-1]
      target = File.join(target_dir, rel)
      FileUtils.mkdir_p(File.dirname(target))
      cmd('cp', '-pRL', f, target)
    end

    if File.exist?(site_start_el_file) &&
       File.read(site_start_el_file).include?(PATH_PATCH)
      return
    end

    debug "Patching '#{relative_path(site_start_el_file)}' to allow Emacs to " \
          'find bundled C sources'
    File.open(site_start_el_file, 'a') { |f| f.puts("\n#{PATH_PATCH}") }
  end

  private

  def site_start_el_file
    @site_start_el_file ||= File.join(resources_dir, 'lisp', 'site-start.el')
  end
end

class LibEmbedder < AbstractEmbedder
  attr_reader :lib_source
  attr_reader :extra_libs
  attr_reader :relink_eln_files

  def initialize(app, lib_source, extra_libs = [], relink_eln_files: true)
    super(app)

    @lib_source = lib_source
    @extra_libs = extra_libs
    @relink_eln_files = relink_eln_files
  end

  def embed
    info 'Bundling shared libraries into Emacs.app...'

    binary = "#{bin}-bin" if File.exist?("#{bin}-bin")
    binary ||= bin

    FileUtils.cd(File.dirname(app)) do
      rel_path = Pathname.new(lib_dir).relative_path_from(
        Pathname.new(File.dirname(binary))
      ).to_s
      rpath = File.join('@executable_path', rel_path)

      copy, relink = build_bundle_plan(binary)

      extra_libs.each do |lib|
        extras_copy, extras_relink = build_bundle_plan(
          lib, copy_macho_file: true
        )
        copy.concat(extras_copy)
        relink.concat(extras_relink)
      end

      if relink_eln_files && eln_files.any?
        info "Bundling shared libraries for #{eln_files.size} *.eln files " \
             'within Emacs.app'

        eln_files.each do |f|
          eln_copy, eln_relink = build_bundle_plan(f)
          copy.concat(eln_copy)
          relink.concat(eln_relink)
        end
      end

      bundle_libs(copy.uniq, relink.uniq)
      set_rpath(binary, rpath)
    end
  end

  private

  def eln_files
    @eln_files ||= Dir[File.join(app, 'Contents', '**', '*.eln')]
  end

  def set_rpath(macho_file, rpath)
    return if rpath.nil? || rpath == ''

    mf = MachO.open(macho_file)

    return if mf.rpaths.include?(rpath)

    debug "Setting rpath for '#{relative_path(macho_file)}' to: #{rpath}"
    mf.add_rpath(rpath)
    while_writable(macho_file) { mf.write! }
  end

  def resolve_dylib_path(path, loader_path: nil, rpaths: nil)
    abs = path.gsub('@executable_path', invocation_dir)
    abs = abs.gsub('@loader_path', loader_path) if loader_path

    if abs.include?('@rpath')
      abs = rpaths.map { |r| abs.gsub('@rpath', r) }
                  .find { |f| File.exist?(f) }

      fatal "Could not resolve path: #{path}" if abs.nil?
    end

    begin
      File.realpath(abs)
    rescue Errno::ENOENT
      File.expand_path(abs)
    end
  end

  def build_bundle_plan(macho_file, copy_macho_file: false)
    macho_file = File.expand_path(macho_file)
    loader_path = File.dirname(macho_file)
    mf = MachO.open(macho_file)

    if macho_file.start_with?(app)
      debug 'Calculating bundling instructions for: ' \
            "#{relative_path(macho_file)}"
    else
      debug "Calculating bundling instructions for: #{macho_file}"
    end

    rpaths = mf.rpaths.map do |r|
      resolve_dylib_path(r, loader_path: loader_path, rpaths: [loader_path])
    end

    copy = []
    relink = []

    relink_target_file = macho_file

    if copy_macho_file
      macho_basename = File.basename(macho_file)
      macho_copy_target = File.join(lib_dir, macho_basename)
      relink_target_file = macho_copy_target
      copy << {
        source: macho_file,
        target: macho_copy_target,
        dylib_id: File.join('@rpath', macho_basename)
      }
    end

    mf.linked_dylibs.each do |linked_dylib|
      debug "-- Processing shared library: #{linked_dylib}"

      lib_filepath = resolve_dylib_path(
        linked_dylib,
        loader_path: loader_path,
        rpaths: rpaths + [loader_path]
      )

      fatal "Could not resolve path for '#{linked_dylib}'" if lib_filepath.nil?

      debug "-- -- Resolved to: #{lib_filepath}" if linked_dylib != lib_filepath

      # Only bundle libraries from lib_source.
      unless lib_filepath.start_with?(lib_source)
        debug "-- -- Skipping, not from lib_source: #{lib_source}"
        next
      end

      unless File.exist?(lib_filepath)
        warn "-- -- Skipping, shared library '#{lib_filepath}' does not exist"
        next
      end

      lib_basename = File.basename(lib_filepath)
      copy_target = File.join(lib_dir, lib_basename)
      new_dylib_id = File.join('@rpath', lib_basename)

      copy.push(
        source: lib_filepath,
        target: copy_target,
        dylib_id: new_dylib_id
      )
      relink.push(
        target_file: relink_target_file,
        old: linked_dylib,
        new: new_dylib_id
      )

      sub_copy, sub_relink = build_bundle_plan(
        lib_filepath, copy_macho_file: true
      )

      copy.concat(sub_copy)
      relink.concat(sub_relink)
    end

    [copy.uniq, relink.uniq]
  end

  def bundle_libs(copy, relink)
    copy.each do |instruction|
      source = instruction[:source]
      target = instruction[:target]
      dylib_id = instruction[:dylib_id]

      next if File.exist?(target)

      debug "Copying '#{source}' to: '#{relative_path(target)}' ('#{dylib_id}')"
      FileUtils.mkdir_p(File.dirname(target))
      cmd('cp', '-pRL', source, target)

      next if dylib_id.nil? || dylib_id == ''

      while_writable(target) do
        MachO::Tools.change_dylib_id(target, dylib_id)
      end
    end

    relink_files = relink.group_by { |r| r[:target_file] }
    relink_files.each do |target_file, relinks|
      debug "Changing linked dylibs in: '#{relative_path(target_file)}'"
      mf = MachO.open(target_file)
      changed = false

      grouped = relinks.group_by { |r| r[:old] }
      grouped.each do |old_dylib, r|
        new_dylib = r.first[:new]
        debug "-- Relinking '#{old_dylib}' as: '#{new_dylib}'"
        unless mf.linked_dylibs.include?(old_dylib)
          warn "-- -- Skipping, not linked: #{old_dylib}"
          next
        end

        mf.change_install_name(old_dylib, new_dylib)
        changed = true
      end

      while_writable(target_file) { mf.write! } if changed
    end
  end

  def while_writable(file)
    mode = File.stat(file).mode
    File.chmod(0o775, file)
    yield
  ensure
    File.chmod(mode, file) if File.exist?(file)
  end
end

class GccLibEmbedder < AbstractEmbedder
  attr_reader :gcc_info

  def initialize(app, gcc_info)
    super(app)
    @gcc_info = gcc_info
  end

  def embed
    if embedded?
      info 'libgccjit already embedded in Emacs.app'
      return
    end

    info 'Bundling libgccjit into Emacs.app'

    if gcc_info.lib_dir.empty?
      fatal "No suitable GCC lib dir found in #{gcc_info.root_dir}"
    end

    FileUtils.mkdir_p(File.dirname(target_dir))
    run_cmd('cp', '-pRL', source_dir, target_dir)
    FileUtils.rm(Dir[File.join(target_dir, '**', '.DS_Store')], force: true)
    run_cmd('chmod', '-R', 'u+w', target_dir)
    if source_darwin_dir != target_darwin_dir
      run_cmd('mv', source_darwin_dir, target_darwin_dir)
    end

    env_setup = ERB.new(NATIVE_COMP_ENV_VAR_TPL).result(gcc_info.get_binding)
    if File.exist?(site_start_el_file) &&
       File.read(site_start_el_file).include?(env_setup)
      return
    end

    debug 'Setting up site-start.el for self-contained native-comp Emacs.app'
    File.open(site_start_el_file, 'a') { |f| f.puts("\n#{env_setup}") }
  end

  private

  NATIVE_COMP_ENV_VAR_TPL = <<~ELISP
    ;; Set LIBRARY_PATH to point at bundled GCC and Xcode Command Line Tools to
    ;; ensure native-comp works.
    (when (and (eq system-type 'darwin)
               (string-match-p "\\.app\\/Contents\\/MacOS\\/?$"
                               invocation-directory))
      (let* ((library-path-env (getenv "LIBRARY_PATH"))
             (devtools-dir
              "/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/usr/lib")
             (gcc-dir (expand-file-name
                       "<%= app_bundle_relative_lib_dir %>"
                       invocation-directory))
             (darwin-dir (expand-file-name
                          "<%= app_bundle_relative_darwin_lib_dir %>"
                          invocation-directory))
             (lib-paths (list)))

        (if library-path-env
            (push library-path-env lib-paths))
        (if (file-directory-p devtools-dir)
            (push devtools-dir lib-paths))
        (push darwin-dir lib-paths)
        (push gcc-dir lib-paths)

        (setenv "LIBRARY_PATH" (mapconcat 'identity lib-paths ":"))))
  ELISP

  def embedded?
    Dir[File.join(target_dir, 'libgcc*')].any?
  end

  def target_dir
    File.join(lib_dir, gcc_info.relative_lib_dir)
  end

  def source_darwin_dir
    File.join(lib_dir, gcc_info.relative_darwin_lib_dir)
  end

  def target_darwin_dir
    File.join(lib_dir, gcc_info.sanitized_relative_darwin_lib_dir)
  end

  def source_dir
    gcc_info.lib_dir
  end

  def relative_dir(path, root)
    Pathname.new(path).relative_path_from(Pathname.new(root)).to_s
  end

  def site_start_el_file
    @site_start_el_file ||= File.join(resources_dir, 'lisp', 'site-start.el')
  end
end

class GccInfo
  include Output

  def root_dir
    @root_dir ||= `brew --prefix gcc`.chomp
  end

  def major_version
    @major_version ||= File.basename(lib_dir)
  end

  def lib_dir
    @lib_dir ||=
      Dir[File.join(root_dir, 'lib/gcc/*/libgcc*')]
      .map { |path| File.dirname(path) }
      .select { |path| File.basename(path).match(/^\d+$/) }
      .max_by { |path| File.basename(path).to_i }
  end

  def relative_lib_dir
    @relative_lib_dir ||= relative_dir(lib_dir, File.join(root_dir, 'lib'))
  end

  def darwin_lib_dir
    @darwin_lib_dir ||=
      Dir[File.join(lib_dir, 'gcc/*apple-darwin*/*')].max_by do |path|
        [
          File.basename(File.dirname(path)).match(/darwin(\d+)$/)[1].to_i,
          File.basename(path).split('.').map(&:to_i)
        ]
      end
  end

  def relative_darwin_lib_dir
    @relative_darwin_lib_dir ||=
      relative_dir(darwin_lib_dir, File.join(root_dir, 'lib'))
  end

  # Sanitize folder name with full "MAJOR.MINOR.PATCH" version number to just
  # the MAJOR version. Apple's codesign CLI tool throws a "bundle format
  # unrecognized" error if there are any folders with two dots in their name
  # within the Emacs.app application bundle.
  def sanitized_relative_darwin_lib_dir
    @sanitized_relative_darwin_lib_dir ||=
      File.join(
        File.dirname(relative_darwin_lib_dir),
        File.basename(relative_darwin_lib_dir).gsub('.', '_')
      )
  end

  def app_bundle_relative_lib_dir
    @app_bundle_relative_lib_dir ||=
      relative_dir(
        File.join(embedder.lib_dir, relative_lib_dir),
        embedder.invocation_dir
      )
  end

  def app_bundle_relative_darwin_lib_dir
    @app_bundle_relative_darwin_lib_dir ||=
      relative_dir(
        File.join(embedder.lib_dir, sanitized_relative_darwin_lib_dir),
        embedder.invocation_dir
      )
  end

  def libgccjit_root_dir
    @libgccjit_root_dir ||= `brew --prefix libgccjit`.chomp
  end

  def libgccjit_major_version
    @libgccjit_major_version ||= File.basename(libgccjit_lib_dir.to_s)
  end

  def libgccjit_lib_dir
    @libgccjit_lib_dir ||=
      Dir[
        File.join(libgccjit_root_dir, 'lib/gcc/*/libgccjit*.dylib'),
        File.join(libgccjit_root_dir, 'lib/gcc/*/libgccjit.so*')
      ]
      .map { |path| File.dirname(path) }
      .select { |path| File.basename(path).match(/^\d+$/) }
      .max_by { |path| File.basename(path).to_i }
  end

  def verify_libgccjit
    fatal 'gcc not installed' unless Dir.exist?(root_dir)
    fatal 'libgccjit not installed' unless Dir.exist?(libgccjit_root_dir)

    if libgccjit_lib_dir.empty?
      fatal "Detected libgccjit (#{libgccjit_root_dir}) does not have any " \
            'libgccjit.so* files. Please try reinstalling libgccjit: ' \
            'brew reinstall libgccjit'
    end

    return if major_version == libgccjit_major_version

    fatal <<~TEXT
      Detected GCC and libgccjit library paths do not belong to the same major
      version of GCC. Detected paths:
        - #{lib_dir}
        - #{libgccjit_lib_dir}
    TEXT
  end

  def get_binding # rubocop:disable Naming/AccessorMethodName
    binding
  end

  private

  def embedder
    @embedder ||= AbstractEmbedder.new(Dir.mktmpdir(%w[Emacs .app]))
  end

  def relative_dir(path, root)
    Pathname.new(path).relative_path_from(Pathname.new(root)).to_s
  end
end

if __FILE__ == $PROGRAM_NAME
  cli_options = {
    work_dir: File.expand_path(__dir__),
    native_full_aot: false,
    relink_eln: true,
    native_march: false,
    parallel: Etc.nprocessors,
    rsvg: true,
    dbus: true,
    xwidgets: true,
    tree_sitter: true,
    fd_setsize: 10_000,
    github_src_repo: nil,
    github_auth: true,
    dist_include: ['COPYING'],
    self_sign: true,
    archive: true,
    archive_keep: false,
    log_level: 'info'
  }

  parser = OptionParser.new do |opts|
    opts.banner = <<~DOC
      Usage: ./build-emacs-for-macos [options] <branch/tag/sha>

      Branch, tag, and SHA are from the emacs-mirror/emacs/emacs Github repo,
      available here: https://github.com/emacs-mirror/emacs

      Options:
    DOC

    opts.on(
      '-j',
      '--parallel COUNT',
      'Compile using COUNT parallel processes ' \
      "(detected: #{cli_options[:parallel]})"
    ) { |v| cli_options[:parallel] = v }

    opts.on(
      '--git-sha SHA',
      'Override detected git SHA of specified ' \
      'branch allowing builds of old commits'
    ) { |v| cli_options[:git_sha] = v }

    opts.on(
      '--[no-]xwidgets',
      'Enable/disable XWidgets if supported ' \
      '(default: enabled)'
    ) { |v| cli_options[:xwidgets] = v }

    opts.on(
      '--[no-]tree-sitter',
      'Enable/disable tree-sitter if supported ' \
      '(default: enabled)'
    ) { |v| cli_options[:tree_sitter] = v }

    opts.on(
      '--[no-]native-comp',
      'Enable/disable native-comp ' \
      '(default: enabled if supported)'
    ) { |v| cli_options[:native_comp] = v }

    opts.on(
      '--[no-]native-march',
      'Enable/disable -march=native CFLAG' \
      '(default: disabled)'
    ) { |v| cli_options[:native_march] = v }

    opts.on(
      '--[no-]native-full-aot',
      'Enable/disable NATIVE_FULL_AOT / Ahead of Time compilation ' \
      '(default: disabled)'
    ) { |v| cli_options[:native_full_aot] = v }

    opts.on(
      '--[no-]relink-eln-files',
      'Enable/disable re-linking shared libraries in bundled *.eln ' \
      'files (default: enabled)'
    ) { |v| cli_options[:relink_eln] = v }

    opts.on(
      '--[no-]rsvg',
      'Enable/disable SVG image support via librsvg ' \
      '(default: enabled)'
    ) { |v| cli_options[:rsvg] = v }

    opts.on(
      '--[no-]dbus',
      'Enable/disable dbus support (default: enabled)'
    ) { |v| cli_options[:dbus] = v }

    opts.on(
      '--no-titlebar',
      'Apply no-titlebar patch (default: disabled)'
    ) { cli_options[:no_titlebar] = true }

    opts.on('--posix-spawn', 'Apply posix-spawn patch (deprecated)') do
      warn '==> WARN: posix-spawn patch is deprecated and has no effect.'
    end

    opts.on(
      '--no-frame-refocus',
      'Apply no-frame-refocus patch (default: disabled)'
    ) { cli_options[:no_frame_refocus] = true }

    opts.on('--[no-]poll', 'Apply poll patch (deprecated)') do
      warn '==> WARN: poll patch is deprecated and has no effect.'
    end

    opts.on(
      '--[no-]fd-setsize SIZE',
      'Set an file descriptor (max open files) limit (default: 10000)'
    ) { |v| cli_options[:fd_setsize] = v.respond_to?(:to_i) ? v.to_i : 0 }

    opts.on(
      '--github-src-repo REPO',
      'Specify a GitHub repo to download source tarballs from ' \
      '(default: emacs-mirror/emacs)'
    ) { |v| cli_options[:github_src_repo] = v }

    opts.on(
      '--[no-]github-auth',
      'Make authenticated GitHub API requests if GITHUB_TOKEN ' \
      'environment variable is set.' \
      '(default: enabled)'
    ) { |v| cli_options[:github_auth] = v }

    opts.on(
      '--work-dir DIR',
      'Specify a working directory where tarballs, sources, and ' \
      'builds will be stored and worked with'
    ) { |v| cli_options[:work_dir] = v }

    opts.on(
      '-o DIR',
      '--output DIR',
      'Output directory for finished builds ' \
      '(default: <work-dir>/builds)'
    ) { |v| cli_options[:output] = v }

    opts.on('--build-name NAME', 'Override generated build name') do |v|
      cli_options[:build_name] = v
    end

    opts.on(
      '--dist-include x,y,z',
      'List of extra files to copy from Emacs source into build ' \
      'folder/archive (default: COPYING)'
    ) { |v| cli_options[:dist_include] = v }

    opts.on(
      '--[no-]self-sign',
      'Enable/disable self-signing of Emacs.app (default: enabled)'
    ) { |v| cli_options[:self_sign] = v }

    opts.on(
      '--[no-]archive',
      'Enable/disable creating *.tbz archive (default: enabled)'
    ) { |v| cli_options[:archive] = v }

    opts.on(
      '--[no-]archive-keep-build-dir',
      'Enable/disable keeping source folder for archive ' \
      '(default: disabled)'
    ) { |v| cli_options[:archive_keep] = v }

    opts.on(
      '--log-level LEVEL',
      'Build script log level (default: info)'
    ) { |v| cli_options[:log_level] = v }

    opts.on(
      '--plan FILE',
      'Follow given plan file, instead of using given git ref/sha'
    ) { |v| cli_options[:plan] = v }
  end

  begin
    parser.parse!

    Output.log_level = cli_options[:log_level]
    work_dir = cli_options.delete(:work_dir)
    Build.new(work_dir, ARGV.shift, cli_options).build
  rescue Error => e
    warn "ERROR: #{e.message}"
    exit 1
  end
end
